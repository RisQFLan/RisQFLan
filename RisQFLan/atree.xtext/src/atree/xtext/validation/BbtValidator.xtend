/*
 * generated by Xtext 2.13.0
 */
package atree.xtext.validation

import org.eclipse.xtext.validation.Check
import java.util.HashSet
import atree.xtext.bbt.ModelDefinition
import atree.xtext.bbt.BbtPackage
import atree.xtext.bbt.Variables
import atree.xtext.bbt.AttackNodes
import atree.xtext.bbt.DefenseNodes
import atree.xtext.generator.BbtGenerator
import atree.xtext.bbt.Edges
import atree.xtext.bbt.Attributes
import atree.xtext.bbt.Attackers
//import atree.xtext.bbt.AttackModels
import atree.xtext.bbt.DefenseNode
import atree.xtext.bbt.AttackNode
import atree.xtext.bbt.Actions
import atree.xtext.bbt.AttackDiagram
import atree.xtext.bbt.KNRelation
import atree.xtext.bbt.CountermeasureNode
import atree.xtext.bbt.CountermeasureNodes
import atree.xtext.bbt.AttackDetectionRates
import atree.xtext.bbt.AttackDetectionRateValue
import java.util.HashMap
import atree.xtext.bbt.DefenseEffectiveness
import atree.xtext.bbt.OANDRelation
import atree.xtext.bbt.ANDRelation
import atree.xtext.bbt.ORRelation
import atree.xtext.bbt.ActionConstraints
import atree.xtext.bbt.InitialAttacks
import atree.xtext.bbt.Analysis
import atree.xtext.bbt.QuantitativeConstraints
import atree.xtext.MyParserUtil
import atree.xtext.bbt.Simulate

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BbtValidator extends AbstractBbtValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					BbtPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
			
	@Check
	def checkModel(ModelDefinition model)
	{
		var allNames = new HashSet<String>();
		var duplNames = new HashSet<String>();
		var nodes = new HashSet<String>();
		
		var dleaves = new HashSet<String>();
		var aleaves = new HashSet<String>();
		var cnodes = new HashSet<String>();
		
		var variablesFlag = false;
		var attackNodesFlag = false;
		var defenseNodesFlag = false;
		var countermeasureNodesFlag = false;
		var edgesFlag = false;
		var attributesFlag = false;
		var attackDetectionRatesFlag = false;
		var attackersFlag = false;
		var defenseEffectivenessFlag = false;
//		var attackModelsFlag = false;
		var actionsFlag = false;
		var actionConstraintsFlag = false;
		var attackDiagramFlag = false;
		var initialAttackFlag = false;
		var quantitativeConstraintsFlag = false;
		var analysisFlag = false;
		var simulateFlag = false;
		
		if (!Character.isUpperCase(model.name.charAt(0))) {
			warning('Model name should start with a capital', 
					BbtPackage.Literals.MODEL_DEFINITION__NAME)
		}
		
		for (elem : model.elements)
		{
			if (elem instanceof ActionConstraints)
			{
				if (actionConstraintsFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Action Constraints!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				actionConstraintsFlag = true;
			}
			if (elem instanceof InitialAttacks)
			{
				if (initialAttackFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Initial Attacks!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				initialAttackFlag = true;
			}
			if (elem instanceof QuantitativeConstraints)
			{
				if (quantitativeConstraintsFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Quantitative Constraints!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				quantitativeConstraintsFlag = true;
			}
			if (elem instanceof Analysis)
			{
				if (analysisFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Analysis!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				if (simulateFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain both Analysis and Simulate!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				analysisFlag = true;
			}
			if (elem instanceof Simulate)
			{
				if (simulateFlag)
				{
					var msg = 'The model cannot contain multiple instances of Simulate!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				if (analysisFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain both Analysis and Simulate!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				simulateFlag = true;
			}
			if (elem instanceof Variables)
			{
				if (variablesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Variables!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				variablesFlag = true;
				for (v : elem.variables)
				{
					duplNames(v.name,allNames,duplNames)
				}
			}
			if (elem instanceof AttackNodes)
			{				
				if (attackNodesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Action Nodes!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				attackNodesFlag = true;
				for (n : elem.attackNodes)
				{
					nodes.add(BbtGenerator.getNodeName(n).trim)
					duplNames(BbtGenerator.getNodeName(n),allNames,duplNames)
					
					aleaves.add(BbtGenerator.getNodeName(n).trim)
				}
			}
			if (elem instanceof DefenseNodes)
			{				
				if (defenseNodesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Defense Nodes!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				defenseNodesFlag = true;
				for (n : elem.defenseNodes)
				{
					nodes.add(BbtGenerator.getNodeName(n).trim)
					duplNames(BbtGenerator.getNodeName(n),allNames,duplNames)
					
					dleaves.add(BbtGenerator.getNodeName(n).trim)
				}
			}
			if (elem instanceof CountermeasureNodes)
			{
				if (countermeasureNodesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Countermeasure Nodes!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				countermeasureNodesFlag = true;
				for (n : elem.countermeasureNodes)
				{
					nodes.add(BbtGenerator.getNodeName(n).trim)
					duplNames(BbtGenerator.getNodeName(n),allNames,duplNames)	
					
					cnodes.add(BbtGenerator.getNodeName(n).trim)				
				}
			}
			if (elem instanceof Edges)
			{
				if (edgesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Edges!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				edgesFlag = true;
				var relatednodes = new HashSet<String>();
				for (e : elem.edges)
				{										
					var pname = BbtGenerator.getNodeName(e.parent).trim
					relatednodes.add(pname)
					var children = BbtGenerator.getRelationChildren(e)
					
					var dnode = e.parent instanceof DefenseNode
					var anode = e.parent instanceof AttackNode
					
					for (c : children)
					{
						var name = BbtGenerator.getNodeName(c).trim

						relatednodes.add(name)
						
						if (dnode && c instanceof DefenseNode)
						{
							dleaves.remove(BbtGenerator.getNodeName(e.parent).trim)
						}
						else if (anode && c instanceof AttackNode)
						{
							aleaves.remove(BbtGenerator.getNodeName(e.parent).trim)
						}
					}	
					
				}
				// All nodes should have a relation
				if (nodes.size > relatednodes.size)
				{
					for (n : relatednodes)
					{
						nodes.remove(n)
					}
					var msg = nodes.toString
					msg = msg.substring(1,msg.length-1)
					if(nodes.size == 1)
					{
						msg = 'Node not appearing in attack tree: ' + msg
					}
					else
					{
						msg = 'Nodes not appearing in attack tree: ' + msg
					}
					warning(msg,BbtPackage.eINSTANCE.modelDefinition_Name) // Maybe give edges a name and refer to this.
				}
			}
			if (elem instanceof Attributes)
			{
				if (attributesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Attributes!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				attributesFlag = true;
				for (a : elem.attributes)
				{
					duplNames(a.name,allNames,duplNames)
				}
			}
			if (elem instanceof Attackers)
			{
				if (attackersFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Attackers!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				attackersFlag = true;
				for (a : elem.attackers)
				{
					duplNames(a.name,allNames,duplNames)
				}
			}
			if (elem instanceof AttackDetectionRates)
			{
				if (attackDetectionRatesFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Attack Detection Rates!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				attackDetectionRatesFlag = true;
				for (adr : elem.values)
				{
					if (adr instanceof AttackDetectionRateValue)
					{
						if (adr.value.value > 1.0)
						{
							var msg = 'Detection rate must be in interval [0;1]'
							error(msg,adr,BbtPackage.eINSTANCE.attackDetectionRateValue_Value)
						}			
					}
				}
			}
			if (elem instanceof DefenseEffectiveness)
			{
				if (defenseEffectivenessFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Defense Effectiveness!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				defenseEffectivenessFlag = true;
				// Key = attacknodes with value as corresponding defense nodes
				var HashMap<String,HashSet<String>> anmap = new HashMap<String,HashSet<String>>();
				var HashMap<String,HashSet<String>> attmap = new HashMap<String,HashSet<String>>();
				
				var all = 'ALL'
				
				for (dp : elem.defenseEffectiveness)
				{
					var dnode = BbtGenerator.getNodeName(dp.defenseNode).trim	
					
//					var dpnodes = new HashSet<String>();
					//CHECK INSTANCE OF NODE
					if (dp.defenseNode instanceof AttackNode)
					{
						var msg = 'Effectiveness can only be specified for defense or countermeasure nodes'
						error(msg,dp,BbtPackage.eINSTANCE.defenseEffectivenessValues_DefenseNode)
					}
					else
					{
//						dpnodes.add(BbtGenerator.getNodeName(dp.defenseNode).trim)
						if (dp.value.value > 1.0)
						{
							var msg = 'Effectiveness must be in interval [0;1]'
							error(msg,dp,BbtPackage.eINSTANCE.defenseEffectivenessValues_Value)
						}	
					}
					
					// Issue a warning if defense effectiveness is already specified.
					var anexists = false
					var attexists = false
					
					// Check if defense is specified for attack nodes
					if (anmap.containsKey(all) && anmap.get(all).contains(dnode))
					{
						anexists = true
					}	
					else if (dp.attackNodes.nodes !== null && !dp.attackNodes.nodes.empty)
					{
						for (an : dp.attackNodes.nodes)
						{
							var ann = (an as AttackNode).name.trim
							if (anmap.containsKey(ann) && anmap.get(ann).contains(dnode))
							{
								anexists = true
							}
						}
					}
					// Now check for attackers
					if (attmap.containsKey(all) && attmap.get(all).contains(dnode))
					{
						attexists = true
					}
					else if (dp.defenseEffectivenessAttackers !== null && !dp.defenseEffectivenessAttackers.attackers.empty)
					{
						// Check if attacker already is a part of set of specified attackers
						for (at : dp.defenseEffectivenessAttackers.attackers)
						{
							var attn = at.name.trim
							if (attmap.containsKey(attn))
							{
								if (attmap.get(attn).contains(dnode))
								{
									attexists = true
								}
							}
						}
					}
					// ELSE: Would handle ALL as specified Attacker. This is not necessary, however.
					
					if (anexists && attexists)
					{
						var msg = 'Defense effectiveness for ' + dnode + ' is already specified for attacker/attack node combination'
						warning(msg,dp,BbtPackage.eINSTANCE.defenseEffectivenessValues_DefenseNode)						
					}
					else // ADD TO MAPS!!!
					{
						if (!anexists)
						{
							if (dp.attackNodes.nodes !== null && !dp.attackNodes.nodes.empty)
							{
								for (an : dp.attackNodes.nodes)
								{
									var ann = an.name.trim
									if (anmap.containsKey(ann))
									{
										anmap.get(ann).add(dnode)
									}
									else
									{
										var HashSet<String> lst = new HashSet<String>();
										lst.add(dnode)
										anmap.put(ann,lst)
									}
								}
							}			
							else
							{
								if (anmap.containsKey(all))
								{
									anmap.get(all).add(dnode)
								}
								else
								{
									var HashSet<String> lst = new HashSet<String>();
									lst.add(dnode)
									anmap.put(all,lst)
								}
							}				
						}
						if (!attexists)
						{
							if (dp.defenseEffectivenessAttackers !== null && !dp.defenseEffectivenessAttackers.attackers.empty)
							{
								for (att : dp.defenseEffectivenessAttackers.attackers)
								{
									var attn = att.name.trim
									if (attmap.containsKey(attn))
									{
										attmap.get(attn).add(dnode)
									}
									else
									{
										var HashSet<String> lst = new HashSet<String>();
										lst.add(dnode)
										attmap.put(attn,lst)
									}
								}
							}			
							else
							{
								if (attmap.containsKey(all))
								{
									attmap.get(all).add(dnode)
								}
								else
								{
									var HashSet<String> lst = new HashSet<String>();
									lst.add(dnode)
									attmap.put(all,lst)
								}
							}											
						}

					}
					
					// Leaf nodes must be checked for each attacker... 
//					if (!dpnodes.containsAll(dleaves))
//					{
//						var missingnodes = new HashSet<String>();
//						for (l : dleaves)
//						{						
//							if (!dpnodes.contains(l))
//							{
//								missingnodes.add(l)
//							}
//						}
//						if (missingnodes.size == 1)	// Perhaps this should be done for node_ref to better specify error location
//						{
//							var msg = 'Effectiveness should be specified for leaf node: ' + missingnodes.toString
//							error(msg,dp,BbtPackage.eINSTANCE.defenseProbability_Attacker)
//						}
//						else if (missingnodes.size > 1)
//						{
//							var msg = 'Effectiveness should be specified for leaf nodes: ' + missingnodes.toString
//							error(msg,dp,BbtPackage.eINSTANCE.defenseProbability_Attacker)
//						}
//					}
//					if (!dpnodes.containsAll(cnodes))
//					{
//						var missingnodes = new HashSet<String>();
//						for (c : cnodes)
//						{						
//							if (!dpnodes.contains(c))
//							{
//								missingnodes.add(c)
//							}
//						}
//						if (missingnodes.size == 1)	// Perhaps this should be done for node_ref to better specify error location
//						{
//							var msg = 'Effectiveness should be specified for countermeasure node: ' + missingnodes.toString
//							error(msg,dp,BbtPackage.eINSTANCE.defenseProbability_Attacker)
//						}
//						else if (missingnodes.size > 1)
//						{
//							var msg = 'Effectiveness should be specified for countermeasure nodes: ' + missingnodes.toString
//							error(msg,dp,BbtPackage.eINSTANCE.defenseProbability_Attacker)
//						}
//					}
				}
			}
//			if (elem instanceof AttackModels)
//			{
//				if (attackModelsFlag) // Must contain multiple instances of the element. This is not allowed
//				{
//					var msg = 'The model cannot contain multiple instances of Attack Models!';
//					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
//				}
//				attackModelsFlag = true;
//				for (am : elem.attackModels)
//				{
//					for (v : am.values)
//					{
//						if (aleaves.contains(BbtGenerator.getNodeName(v.node).trim) 
//							&& v.optionalparameters.successFailure === null)
//						{
//							var msg = 'Success/failure rate should be specified for leaf node: ' 
//								+ BbtGenerator.getNodeName(v.node)
//							error(msg,v,BbtPackage.eINSTANCE.attackModelState_Optionalparameters)
//						}
//					}
//				}
//			}
			if (elem instanceof Actions)
			{
				if (actionsFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Actions!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				actionsFlag = true;
				for (a : elem.actions)
				{
					duplNames(a.name,allNames,duplNames)
				}
			}
			if (elem instanceof AttackDiagram)
			{
				if (attackDiagramFlag) // Must contain multiple instances of the element. This is not allowed
				{
					var msg = 'The model cannot contain multiple instances of Attack Diagram!';
					error(msg,BbtPackage.eINSTANCE.modelDefinition_Name);
				}
				attackDiagramFlag = true;
				for (a : elem.attacks)
				{
					for (s : a.states.states)
					{
						duplNames(s.name,allNames,duplNames)
					}
				}
			}
			
			
		}
		
		// Name Validation
		if(duplNames.size>0)
		{
			var msg = duplNames.toString
			msg = msg.substring(1,msg.length-1)
			if(duplNames.size==1)
			{
				msg = 'Resolve the following duplicate name: '+msg	
			}
			else
			{
				msg = 'Resolve the following duplicate names: '+msg	
			}
			error(msg,BbtPackage.eINSTANCE.modelDefinition_Name)
		}
		for(n:allNames)
		{
			if(isReserved(n))
			{
				var msg= 'Name '+n+' is reserved'
				error(msg,BbtPackage.eINSTANCE.modelDefinition_Name)
			}
		}
	}
	
	@Check
	def checkEdges(Edges elem)
	{
		// ADD VALIDATION FOR CYCLES!
		var HashMap<String,HashSet<String>> parents = new HashMap<String,HashSet<String>>();
		
		var HashMap<String,HashSet<String>> nodemap = new HashMap<String,HashSet<String>>();
		var relatednodes = new HashSet<String>();
		for (e : elem.edges)
		{					
			var setOfChildren = new HashSet<String>();
			
			var pname = BbtGenerator.getNodeName(e.parent).trim
			relatednodes.add(pname)
			var children = BbtGenerator.getRelationChildren(e)
			
			var anode = e.parent instanceof AttackNode
			
			var ac = false 
			var dc = false
			var cc = false
			
			for (c : children)
			{
				var name = BbtGenerator.getNodeName(c).trim
				if (pname.equals(name)) // Check if parent = child
				{
					var msg = 'Node ' + pname + ' cannot have itself as a child'
					error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
				}
				else if (checkAncestors(name, pname, parents)) // Check for cycle
				{
					var msg = 'Cycle found in attack tree: ' + name + ' cannot be its own ancestor'
					error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
				}
				else if (parents.containsKey(name)) // Add parent to map
				{
					parents.get(name).add(pname)
				}
				else
				{
					var HashSet<String> lst = new HashSet<String>()
					lst.add(pname)
					parents.put(name,lst)
				}
				
				relatednodes.add(name)
				
				if (c instanceof AttackNode)
				{
					ac = true
				}
				else if (c instanceof DefenseNode)
				{
					dc = true
				}
				else if (c instanceof CountermeasureNode)
				{
					cc = true
				}
				
				if (!anode && c instanceof CountermeasureNode)
				{
					var msg = 'Countermeasure nodes can only be placed on attack nodes'
					error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
				}
				// Does node already exist in relation
				if (setOfChildren.contains(name))
				{
					var msg = 'Node ' + name + 'already exists in relation'
					error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
				}
				else
				{
					setOfChildren.add(name)
				}
			}	
			// Nodes should only have children of same type in relation
			if ((ac && dc) || (ac && cc) || (dc && cc))
			{
				var msg = 'Relations can only have children of same type'
				error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
			}
			
			// Check if node is children of the same parent multiple times
			if (nodemap.containsKey(pname))
			{
				for (n : setOfChildren)
				{
					if (nodemap.get(pname).contains(n))
					{
						var msg = 'Node ' + n + ' already exists in a relation for ' + pname
						error(msg,e,BbtPackage.eINSTANCE.edgeType_Parent)
					}
					else
					{
						nodemap.get(pname).add(n)
					}
				}
			}
			else
			{
				nodemap.put(pname,setOfChildren)
			}
		}
	}
	
	@Check
	def checkKNRelation(KNRelation e)
	{

		if (e.value > e.childrenSet.children.size)
		{
			var msg = 'N is larger than set size for node: ' + e.parent
			error(msg,e,BbtPackage.eINSTANCE.KNRelation_Value)
		}
		
		for (c : e.childrenSet.children)
		{
			if (c instanceof CountermeasureNode)
			{
				var msg = 'Children of K of N relations cannot be countermeasure nodes.'
				error(msg,e,BbtPackage.eINSTANCE.KNRelation_ChildrenSet)			
			}
		}
	}
	
	@Check
	def checkOANDRelation(OANDRelation e)
	{	
		for (c : e.childrenSeq.children)
		{
			if (!(c instanceof AttackNode))
			{
				var msg = 'Children of O-AND relations can only be attack nodes.'
				error(msg,e,BbtPackage.eINSTANCE.OANDRelation_ChildrenSeq)			
			}
		}
	}
	
	@Check
	def checkANDRelation(ANDRelation e)
	{	
		if (e.childrenSet.children.size > 1)
		{
			for (c : e.childrenSet.children)
			{
				if (c instanceof CountermeasureNode)
				{
					var msg = 'Children of AND-relations cannot be countermeasure nodes.'
					error(msg,e,BbtPackage.eINSTANCE.ANDRelation_ChildrenSet)			
				}
			}	
		} 
	}
	
	@Check
	def checkORRelation(ORRelation e)
	{
		if (!(e.parent instanceof AttackNode))
		{
			for (c : e.childrenSet.children)
			{
				if (c instanceof CountermeasureNode)
				{
					var msg = 'Children of OR-relations can only be countermeasure nodes if parent is an attack node.'
					error(msg,e,BbtPackage.eINSTANCE.ORRelation_ChildrenSet)			
				}
			}	
		} 
	}
	
	def duplNames(String name, HashSet<String> allNames, HashSet<String> duplicateNames)
	{
		var ret=allNames.add(name)
		if(!ret){
			duplicateNames.add(name)
		}
	}
	
	def isReserved(String n) 
	{
		var nl = n.trim;
		if(MyParserUtil.RESERVEDKEYWORDS.contains(nl))
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	def Boolean checkAncestors(String name, String entry, HashMap<String, HashSet<String>> map) 
	{
		if (map.containsKey(entry))
		{
			for (p : map.get(entry))
			{
				if (p.equals(name) || checkAncestors(name,p,map))
				{
					return true
				}
			}
		}
		
		return false
	}
	
}
