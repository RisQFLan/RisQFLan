/*
 * generated by Xtext 2.13.0
 */
package atree.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.Iterator

import atree.xtext.bbt.Node
import atree.xtext.bbt.AttackNode
import atree.xtext.bbt.DefenseNode
import atree.xtext.bbt.EdgeType
import atree.xtext.bbt.ORRelation
import atree.xtext.bbt.ANDRelation
import atree.xtext.bbt.OANDRelation
import atree.xtext.bbt.KNRelation
import atree.xtext.bbt.CountermeasureNode
import atree.xtext.bbt.ModelDefinition
import atree.xtext.bbt.Variable
import atree.xtext.bbt.Expression
import atree.xtext.bbt.NumberLiteral
import atree.xtext.bbt.RefToVariable
import atree.xtext.bbt.Predicate
import atree.xtext.bbt.Addition
import atree.xtext.bbt.AdditionWithPredicates
import atree.xtext.bbt.Subtraction
import atree.xtext.bbt.SubtractionWithPredicates
import atree.xtext.bbt.Multiplication
import atree.xtext.bbt.MultiplicationWithPredicates
import atree.xtext.bbt.MinusPrimary
import atree.xtext.bbt.MinusPrimaryWithPredicates
import atree.xtext.bbt.Attribute
import atree.xtext.bbt.Attacker
import atree.xtext.bbt.DefenseEffectivenessValues
import atree.xtext.bbt.Action
import atree.xtext.bbt.ActionConstraints
import atree.xtext.bbt.QuantitativeConstraints
import atree.xtext.bbt.AttacksOfDiagram
import atree.xtext.bbt.InitialAttack
import atree.xtext.MyParserUtil
import atree.xtext.bbt.AttackDetectionRateValue
import atree.xtext.bbt.ActionRequires
import atree.xtext.bbt.StoreModifierActionOrReferenceToAction
import atree.xtext.bbt.ReferenceToAction
import atree.xtext.bbt.StoreModifierActions
import atree.xtext.bbt.AddAction
import atree.xtext.bbt.RemoveAction
import atree.xtext.bbt.FailAction
import atree.xtext.bbt.QueryAction
import atree.xtext.bbt.BoolExpr
import atree.xtext.bbt.HasNode
import atree.xtext.bbt.AllowedNode
import atree.xtext.bbt.FalseConstraint
import atree.xtext.bbt.TrueConstraint
import atree.xtext.bbt.NotConstraintExpr
import atree.xtext.bbt.AndBoolConstraintExpr
import atree.xtext.bbt.OrBoolConstraintExpr
import atree.xtext.bbt.ImpliesBoolConstraintExpr
import atree.xtext.bbt.DisequationOfPredicateExpr
//import atree.xtext.bbt.ProcessTransition
//import atree.xtext.bbt.ZeroProcess
//import atree.xtext.bbt.ReferenceToProcessState
import atree.xtext.bbt.AskOrStoreModifierActionOrReferenceToAction
import atree.xtext.bbt.SideEffects
import java.util.HashMap
import java.util.Set
import java.util.HashSet
import java.util.List
import atree.xtext.bbt.Analysis
import atree.xtext.bbt.NonParametricQueries
import atree.xtext.bbt.ParametricQuery
import java.util.LinkedHashMap
import java.util.ArrayList
import atree.xtext.bbt.AttributeValue
import atree.xtext.bbt.ProcessState
import atree.xtext.bbt.ProcessTransition
import atree.xtext.bbt.Division
import atree.xtext.bbt.Power
import org.eclipse.xtext.util.StringInputStream
import atree.xtext.bbt.SteadyStateQuery

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BbtGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		var modelDefs = resource.allContents.filter(typeof(ModelDefinition))
		var modelDef = modelDefs.next
		var modelName = modelDef.name
		var variables = resource.allContents.filter(typeof(Variable))
		var attackNodes = resource.allContents.filter(typeof(AttackNode)).toList
		var defenseNodesList = resource.allContents.filter(typeof(DefenseNode)).toList
		var defenseNodes = resource.allContents.filter(typeof(DefenseNode))
		var countermeasureNodesList = resource.allContents.filter(typeof(CountermeasureNode)).toList
		var countermeasureNodes = resource.allContents.filter(typeof(CountermeasureNode))
		var relationsList = resource.allContents.filter(typeof(EdgeType)).toList
		var relations = resource.allContents.filter(typeof(EdgeType))
		var attributesList = resource.allContents.filter(typeof(Attribute)).toList
		var attributes = resource.allContents.filter(typeof(Attribute))
		var attackers = resource.allContents.filter(typeof(Attacker))
		var defenseEffectivenessList = resource.allContents.filter(typeof(DefenseEffectivenessValues)).toList
		var defenseEffectiveness = resource.allContents.filter(typeof(DefenseEffectivenessValues))
		var actions = resource.allContents.filter(typeof(Action))
		var detectionRatesList = resource.allContents.filter(typeof(AttackDetectionRateValue)).toList
		var detectionRates = resource.allContents.filter(typeof(AttackDetectionRateValue))
		var listOfActionConstraints = resource.allContents.filter(typeof(ActionConstraints))
		var listOfQuantitativeConstraints = resource.allContents.filter(typeof(QuantitativeConstraints))
		var attackDiagramsList = resource.allContents.filter(typeof(AttacksOfDiagram)).toList
		var attackDiagrams = resource.allContents.filter(typeof(AttacksOfDiagram))
		var initialAttacks = resource.allContents.filter(typeof(InitialAttack)).toList
		

		var javaEncoding =//'''package it.imt.qflan.core.models;
'''

import atree.core.attacker.*;
import atree.core.attributes.*;
import atree.core.model.*;
import atree.core.nodes.*;
import atree.core.processes.*;
import atree.core.processes.actions.*;
import atree.core.processes.constraints.*;
import atree.core.variables.*;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class «modelName» implements IAtreeModelBuilder {
	
	public «modelName»(){
		System.out.println("Model builder instantiated");
	}
	public AtreeModel createModel(){
		
		AtreeModel model = new AtreeModel();		
		
		//////////////////
		/////Variables////
		//////////////////
		«writeVariables(variables)»
		
		/////////////
		////Nodes////
		/////////////
		«writeAttackNodes(attackNodes.iterator)»
		«writeDefenseNodes(defenseNodes)»
		«writeCountermeasureNodes(countermeasureNodes)»
		
		/////////////////
		////Relations////
		/////////////////
		«writeRelations(relations)»
		
		//////////////////
		////Attributes////
		//////////////////
		«writeAttributes(attributes)»
		
		/////////////////
		////Attackers////
		/////////////////
		«writeAttackers(attackers)»
		
		/////////////////////////////
		////Defense Effectiveness////
		/////////////////////////////
		«writeDefenseEffectiveness(defenseEffectiveness)»
		
		///////////////
		////Actions////
		///////////////
		«writeActions(actions)»
		
		//////////////////////////////
		////Attack Detection Rates////
		//////////////////////////////
		«writeDetectionRates(detectionRates)»
		
		////////////////////////////////
		////Quantitative Constraints////
		////////////////////////////////
		«writeQuantitativeConstraints(listOfQuantitativeConstraints)»
		
		//////////////////////////
		////Action Constraints////
		//////////////////////////
		«writeActionConstraints(listOfActionConstraints,attackNodes)»
		
		///////////////////////
		////Attack Diagrams////
		///////////////////////
		«writeAttackDiagrams(attackDiagrams,initialAttacks)»
		
		///////////////////////
		////Initial Attacks////
		///////////////////////
		«writeInitialAttacks(initialAttacks)»
		
		return model;
	}
}
'''
		fsa.generateFile(modelName+'.java',javaEncoding)
		
for(e : modelDef.elements){
			if(e instanceof Analysis){
				var query = e.query;
				if(query!==null){
					var queryString=""
					if(query instanceof NonParametricQueries){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=true;
						//hasUntilQuery=false;
					}
					else if(query instanceof ParametricQuery){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=true;
						//hasNonParametricQueries=false;
						//hasUntilQuery=false;
					}
					else if(query instanceof SteadyStateQuery){
						queryString=MyParserUtil.computeQuery(query)
					}
//					else if(query instanceof UntilQuery){
//						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=false;
						//hasUntilQuery=true;
//					} 
					
				
					if(queryString!==null && !queryString.equals("")){
						fsa.generateFile('query'+modelName+'.multiquatex', queryString)
					}
				}
			}
		}
		
		/*fsa.generateFile(modelName+'.java', 
			'All defined actions: ' + 
			resource.allContents
				.filter(typeof(Action))
				.map[name]
				.join(', '))*/
	
	//Here begins generation of .graphviz file (DOT file)
	
	var AttackTree=
	'''
/* Open in your favourite Graphviz viewer, e.g.
 * https://dreampuf.github.io/GraphvizOnline/
 * https://edotor.net/
 */
	digraph «modelName» {
		
		subgraph AttackTree {
			«genAttackNodes(attackNodes.iterator, attributesList, detectionRatesList)»
			«genDefenseNodes(defenseNodesList.iterator, attributesList, defenseEffectivenessList)»
			«genCountermeasureNodes(countermeasureNodesList.iterator, attributesList, defenseEffectivenessList)»
			«genEdges(relationsList.iterator)»
		}
		

	}
	'''
	var fileName =modelName + 'Tree.dot'
	fsa.generateFile(fileName, AttackTree)
	MyParserUtil.generateFigure(new StringInputStream(AttackTree),modelName + 'Tree',resource)
	
	var AttackDiagram=
	'''
/* Open in your favourite Graphviz viewer, e.g.
 * https://dreampuf.github.io/GraphvizOnline/
 * https://edotor.net/
 */
	digraph «modelName» {
		«genStates(attackDiagramsList.iterator,initialAttacks)»
	}
	'''
	fileName=modelName + 'Attacker.dot';
	fsa.generateFile(fileName, AttackDiagram)
	MyParserUtil.generateFigure(new StringInputStream(AttackDiagram),modelName + 'Attacker',resource)
	}
		
		def writeInitialAttacks(List<InitialAttack> initAttacks) {
			var StringBuffer sb = new StringBuffer()
			//TODO: FIX HERE IF ONLY 1 INITIALATTACK!!!!
			if (!initAttacks.empty){
//				while (attacks.hasNext){
				var init = initAttacks.get(0)
				var attacker = init.attacker.name
//				var initialAttacks = init.initialAttacks
				var StringBuffer ia = new StringBuffer("Arrays.asList(")
				if (init.initialAttacks !== null && !init.initialAttacks.empty){
					for (a : init.initialAttacks){
						ia.append(a.name)
						ia.append(",")
					}
					ia.delete(ia.length-1,ia.length);
				}
				ia.append(")")
				sb.append(
'''
model.init(«attacker»,«ia.toString»);
'''
				)
//				}
			}
			return sb.toString
		}
		
		def writeAttackDiagrams(Iterator<AttacksOfDiagram> diagrams,List<InitialAttack> initAttacks) {
			var StringBuffer sb = new StringBuffer();
			var String currentAttacker = null;
			if (!initAttacks.empty){
				currentAttacker = initAttacks.get(0).attacker.name;
			}
			if (!diagrams.empty){
				while (diagrams.hasNext){
					var boolean initialState = true;
					var diagram = diagrams.next
					if (currentAttacker !== null && diagram.attacker.name == currentAttacker){	//Probably requires initial attacks as a method parameter...
						for (state : diagram.states.states){
							sb.append(
'''
ProcessState «state.name» = new ProcessState("«state.name»");
'''
							)
							if (initialState){
								initialState = false
								sb.append(
'''
model.setInitialState(«state.name»);
'''
								)
							}
						}
						for (transition : diagram.transitions.transitions){
							var rate = MyParserUtil.visitExpr(transition.rate)
							var source = transition.source.name
							var target = transition.target.name//computeTarget(transition)
							var sideEffects = visitListOfSideEffects(transition.sideEffects);
							var action = writeActionIncludingAskOrStoreModifierOrFeature(transition.action)
							var actionGuard = visitActionGuard(transition.actionGuard)
							sb.append(
'''
«source».addTransition(new ProcessTransition(«rate»,«action»,«target»,«sideEffects»,«actionGuard»));
'''
							)
						}
					}
				}
				
			}
			return sb.toString
		}
		
		def static visitActionGuard(BoolExpr expr) {
			if (expr !== null){
				return visitConstraint(expr)
			}
			else {
				return "new TrueConstraint()"
			}
		}
		
		def static visitListOfSideEffects(SideEffects effects) {
		var sb = new StringBuilder();
		sb.append("new SideEffect[]{");
		
		if(effects!==null){
			var listOfEffects = effects.effects;
			var size = listOfEffects.size;
			var i=0;
			if(listOfEffects!==null){
				for(eff : listOfEffects){
					var name = eff.refToVar.varname.name
					var expr = eff.value;
					sb.append('''new SideEffect(«name»,«writeExpr(expr)»)''')
					if(i<size-1){
						sb.append(",");
					}
					i++;
				}
			}
		}
		sb.append("}");
		return sb.toString;
	}
		
		def static writeActionIncludingAskOrStoreModifierOrFeature(AskOrStoreModifierActionOrReferenceToAction action) {
		if(action instanceof StoreModifierActionOrReferenceToAction){
			return writeActionIncludingStoreModifierOrFeature(action)
		}
		else{
			throw new UnsupportedOperationException("Unsupported action: " + action);
		} 
	}
		
//		def static computeTarget(ProcessTransition transition){
//		var target="ZeroProcess.ZERO"
//		var tt=transition.target
//		if(!(tt instanceof ZeroProcess)){
//			var tt2 = tt as ReferenceToProcessState
//			target = tt2.value.name
//		}
//		return target
//	}
		
		def writeQuantitativeConstraints(Iterator<QuantitativeConstraints> constraints) {
			var StringBuffer sb = new StringBuffer()
			if (!constraints.empty){
				var quantitativeConstraints = constraints.next
				for (constraint : quantitativeConstraints.quantitativeConstraints){
					sb.append(
'''
model.addConstraint(«visitConstraint(constraint)»);
'''
					)
				}
			}
			return sb.toString
		}
		
		def writeActionConstraints(Iterator<ActionConstraints> constraints, List<AttackNode> anodes) {
			var StringBuffer sb = new StringBuffer()
			if (!constraints.empty){
				var actionConstraints = constraints.next
				for (actionReq : actionConstraints.actionConstraints){
					sb.append(
'''
model.addActionConstraint(«visitActionRequires(actionReq)»);
'''
					)
				}
			}
			// This is where do(add/fail/remove/query(node))->(!has(root)) could be specified. Would require all attack nodes to be parsed...
//			sb.append('''//Basic action constraints. Dont perform an action, if root is reached. \n''')
//			var root = anodes.get(0)
			return sb.toString
		}
		
		def static visitActionRequires(ActionRequires constraint) {
			var writtenAction = writeActionIncludingStoreModifierOrFeature(constraint.action)
			var writtenConstraint = visitConstraint(constraint.constraint)
			return '''new ActionRequiresConstraint(«writtenAction», «writtenConstraint»)'''
		}
		
		def static String visitConstraint(BoolExpr constraint) {
			if(constraint instanceof HasNode){
				return '''new HasNodeConstraint(«getNodeName(constraint.node)»)'''
			}
			else if(constraint instanceof AllowedNode){
				return '''new AllowedNodeConstraint(«getNodeName(constraint.node)»)'''
			}
			else if(constraint instanceof FalseConstraint){
				return '''new FalseConstraint()'''
			}
			else if(constraint instanceof TrueConstraint){
				return '''new TrueConstraint()'''
			}
			else if(constraint instanceof NotConstraintExpr){
				return '''new NotConstraintExpr(«visitConstraint(constraint.left)»)'''
			}
			else if(constraint instanceof AndBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.AND)'''
			}
			else if(constraint instanceof OrBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.OR)'''
			}
			else if(constraint instanceof ImpliesBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.IMPLIES)'''
			}
			else if(constraint instanceof DisequationOfPredicateExpr){
				var writtenlhs = writeExpr(constraint.lhs)
				var writtenrhs = writeExpr(constraint.rhs)
				return '''new DisequationOfAttributeExpressions(«writtenlhs»,«writtenrhs»,«writeComparator(constraint.comp)»)''';
			}
			return ""
		}
		
		def static writeComparator(String comp) {
			if(comp.equals(">")){
				return "AttributeExprComparator.GE"
			}
			else if(comp.equals("<")){
				return "AttributeExprComparator.LE"
			}
			else if(comp.equals(">=")){
				return "AttributeExprComparator.GEQ"
			}
			else if(comp.equals("<=")){
				return "AttributeExprComparator.LEQ"
			}
			else if(comp.equals("==")){
				return "AttributeExprComparator.EQ"
			} 
			else if(comp.equals("!=")){
				return "AttributeExprComparator.NOTEQ"
			}
			else{
				throw new UnsupportedOperationException("Unsupported comparator: " + comp);
			}
		}
		
		def static writeActionIncludingStoreModifierOrFeature(StoreModifierActionOrReferenceToAction action) {
			if(action instanceof Action){
				return action.name
			}
			else if(action instanceof ReferenceToAction){
				var referencedActionOrFeautre = action.value
				if(referencedActionOrFeautre instanceof Action){
					return referencedActionOrFeautre.name
				}
			}
			else if(action instanceof StoreModifierActions){
				if(action instanceof AddAction){
					return '''new AddAction(«action.node.nodeName»)'''
				}
				else if(action instanceof RemoveAction){
					return '''new RemoveAction(«action.node.nodeName»)'''
				}
				else if(action instanceof FailAction){
					return '''new FailAction(«action.node.nodeName»)'''
				}
				else if(action instanceof QueryAction){
					return '''new QueryAction(«action.node.nodeName»)'''
				}
				else{
					throw new UnsupportedOperationException("Unsupported action: " + action);
				}
			}
		}
		
		def writeDetectionRates(Iterator<AttackDetectionRateValue> values) {
			var StringBuffer sb = new StringBuffer();
			while (values.hasNext){
				var detectionRate = values.next
				sb.append(
'''
«detectionRate.attackNode.name».setDetectionRate(«MyParserUtil.visitExpr(detectionRate.value)»);
'''
				)
			}
			
			return sb.toString
		}
		
		def writeActions(Iterator<Action> actions) {
			var StringBuffer sb = new StringBuffer();
			while(actions.hasNext){
				var action = actions.next
				sb.append(
'''
NormalAction «action.name» = new NormalAction("«action.name»");
model.addNormalAction(«action.name»);
'''
)
			}
			return sb.toString();
	}	
		
		def writeDefenseEffectiveness(Iterator<DefenseEffectivenessValues> values) {
			var StringBuffer sb = new StringBuffer()
			while (values.hasNext){
				var deVal = values.next
				var StringBuffer attackNodes = new StringBuffer;
				var StringBuffer attackers = new StringBuffer;
				if (deVal.attackNodes.nodes.empty){
					attackNodes.append('''model.getAttackNodes()''')
				}
				else{
					attackNodes.append("Arrays.asList(")
					for (a : deVal.attackNodes.nodes){
						attackNodes.append(a.name)
						attackNodes.append(",")
					}
					attackNodes.delete(attackNodes.length-1,attackNodes.length);
					attackNodes.append(")")
				}
				if (deVal.defenseEffectivenessAttackers.attackers.empty){
					attackers.append('''model.getAttackers()''')
				}
				else {
					attackers.append("Arrays.asList(")
					for (a :deVal.defenseEffectivenessAttackers.attackers){
						attackers.append(a.name)
						attackers.append(",")	
					}
					attackers.delete(attackers.length-1,attackers.length);
					attackers.append(")")
				}
				sb.append(
'''
model.setDefenseEffectivenesss(«attackers.toString», «attackNodes.toString»,«deVal.defenseNode.nodeName»,«MyParserUtil.visitExpr(deVal.value)»);
'''
				)
			}
			return sb.toString
		}
		
		def writeAttackers(Iterator<Attacker> attackers) {
			var StringBuffer sb = new StringBuffer();
			while (attackers.hasNext){
				var a = attackers.next
				sb.append(
'''
Attacker «a.name» = new Attacker ("«a.name»");
model.addAttacker(«a.name»);
'''
				)
			}
			sb.toString
		}
		
		def writeAttributes(Iterator<Attribute> attributes) {
			var StringBuffer sb = new StringBuffer()
			while(attributes.hasNext) {
				var att = attributes.next
				sb.append(
'''
AttributeDef «att.name» = new AttributeDef("«att.name»");
model.addAttributeDef(«att.name»);
'''					
				)
				for (attVal : att.values){
					sb.append(
'''
«att.name».setNodeValue(«attVal.attribute.nodeName»,«MyParserUtil.visitExpr(attVal.value)»);
'''
					)
				}
			}
			return sb.toString;
		}
		
	def writeRelations(Iterator<EdgeType> edgeTypes) {
		var number = 0;
		var LinkedHashMap<String,Set<String>> orRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> andRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> knRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> oandRelations = new LinkedHashMap<String,Set<String>>()
		var StringBuffer sb = new StringBuffer(
'''
LinkedHashMap<String,Set<String>> orRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> andRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> knRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> oandRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,List<String>> childrenMap = new LinkedHashMap<>();
LinkedHashMap<String,Integer> knChildren = new LinkedHashMap<>();
'''
		);
		while (edgeTypes.hasNext){
			var setID = "set" + number
			number++
			var edgeType = edgeTypes.next
			var key = getNodeName(edgeType.parent)
			var StringBuffer childLst = new StringBuffer("Arrays.asList(")
			var children = getRelationChildren(edgeType)
			
			if (!children.empty){
				for (c : children){
					childLst.append('''"«c.nodeName»"''')
					childLst.append(",")
				}
				childLst.delete(childLst.length-1,childLst.length)
			}
			childLst.append(")")
			sb.append(
'''
childrenMap.put("«setID»",«childLst.toString»);
'''
			)
			if (edgeType instanceof ORRelation){
				if (orRelations.containsKey(key)){
					orRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					orRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof ANDRelation){
				if (andRelations.containsKey(key)){
					andRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					andRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof KNRelation){
				sb.append(
'''
knChildren.put("«setID»",«edgeType.value»);
'''
				)
				if (knRelations.containsKey(key)){
					knRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					knRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof OANDRelation){
				if (oandRelations.containsKey(key)){
					oandRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					oandRelations.put(key,setOfID)
				}
			}
		}
		var buildOr = buildRelMap("orRelations",orRelations)
		var buildAnd = buildRelMap("andRelations",andRelations)
		var buildKn = buildRelMap("knRelations",knRelations)
		var buildOAnd = buildRelMap("oandRelations",oandRelations)

		sb.append(
'''
«buildOr»
«buildAnd»
«buildKn»
«buildOAnd»
model.addAllRelations(orRelations,andRelations,knRelations,oandRelations,childrenMap,knChildren);
'''			
		);
		return sb.toString();
	}
		
		def buildRelMap(String name, HashMap<String, Set<String>> map) {
			var StringBuffer sb = new StringBuffer()
			for (key : map.keySet){
				sb.append('''«name».put("«key»",new HashSet<>(Arrays.asList(''')
				for (id : map.get(key)){
					sb.append('''"«id»"''')
					sb.append(",")
				}
				sb.delete(sb.length-1,sb.length)
				sb.append(")));\n")
			}
			return sb.toString
		}
	
	def writeAttackNodes(Iterator<AttackNode> nodes) {
		var sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			sb.append(
'''
AttackNode «node.name» = new AttackNode("«node.name»");
model.addAttackNodeDefinition(«node.name»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	def writeDefenseNodes(Iterator<DefenseNode> nodes) {
		var sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			sb.append(
'''
DefenseNode «node.name» = new DefenseNode("«node.name»");
model.addDefenseNodeDefinition(«node.name»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	def writeCountermeasureNodes(Iterator<CountermeasureNode> nodes) {
		var StringBuffer sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			var aNodes = node.triggers
			var StringBuffer anl = new StringBuffer("Arrays.asList(");
			if (aNodes !== null){
				for (an : aNodes){
					anl.append(an.name)
					anl.append(",")
				}
			}
			anl.delete(anl.length-1,anl.length)
			anl.append(")")
			sb.append(
'''
CountermeasureNode «node.name» = new CountermeasureNode("«node.name»");
model.addCountermeasureNodeDefinition(«node.name»,«anl.toString»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	
	def writeVariables(Iterator<Variable> variables) {
		var sb = new StringBuffer();
		while(variables.hasNext){
			var variable = variables.next
			sb.append(
'''
AtreeVariable «variable.name» = model.addVariable("«variable.name»", «writeExpr(variable.value)»);
'''
)
		}
		sb.append("\n")
		return sb.toString();
	}
	
	def static String writeExpr(Expression expr) {
		var rightVisited = ""
		var leftVisited = ""
		if(expr instanceof NumberLiteral){
			return '''new Constant(«expr.value»)'''
		}
		else if(expr instanceof RefToVariable){
			return '''«expr.varname.name»'''
		}
		else if(expr instanceof Predicate){
			return '''new Attribute(«expr.predicate.name»)'''
		}
		else if(expr instanceof Addition || expr instanceof AdditionWithPredicates){
			if(expr instanceof Addition){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof AdditionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.SUM)'''
		}
		else if(expr instanceof Subtraction || expr instanceof SubtractionWithPredicates){
			if(expr instanceof Subtraction){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof SubtractionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.SUB)'''
		}
		else if(expr instanceof Multiplication || expr instanceof MultiplicationWithPredicates){
			if(expr instanceof Multiplication){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof MultiplicationWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.MULT)'''
		}
		else if(expr instanceof MinusPrimary || expr instanceof MinusPrimaryWithPredicates){
			if(expr instanceof MinusPrimary){
				leftVisited = writeExpr(expr.left) as String
			}
			else if(expr instanceof MinusPrimaryWithPredicates){
				leftVisited = writeExpr(expr.left) as String
			}
			return '''new ArithmeticAttributeExpression(new Constant(0),«leftVisited»,ArithmeticOperation.SUB)'''
		}
		else{
			throw new UnsupportedOperationException("Unsupported expression: " + expr.toString());
		}
	}
	
	def static getNodeName(Node n)
	{
		if(n instanceof AttackNode)
		{
			return n.name;
		}
		else if(n instanceof DefenseNode)
		{
			return n.name;
		} 
		else if(n instanceof CountermeasureNode)
		{
			return n.name;
		}
	}
	def static getRelationChildren(EdgeType e)
	{
		if (e instanceof ORRelation)
		{
			return e.childrenSet.children;
		}
		if (e instanceof ANDRelation)
		{
			return e.childrenSet.children
		}
		if (e instanceof OANDRelation)
		{
			return e.childrenSeq.children
		}
		if (e instanceof KNRelation)
		{
			return e.childrenSet.children
		}
	}
	
	
	//Graphviz methods
	//Generate attack nodes
		def genAttackNodes(Iterator<AttackNode> attackNodes, List<Attribute> attributes, List<AttackDetectionRateValue> detectionRates) {
			if (attackNodes.empty) {
				return ""
			}
			var sb = new StringBuffer()
			sb.append(
			'''
			//AttackNodes definitions
			node [shape=ellipse color=red penwidth=4.0]
			''')
			while (attackNodes.hasNext) {
				var node = attackNodes.next
				var relevantAttributes = getRelevantAttributes(node.name, attributes.iterator)
				var relevantDRates = getRelevantDRates(node.name, detectionRates.iterator)
				sb.append(
					'''
					«node.name» [label=<<table border="0"><tr><td><b><font point-size='20'>«node.name»</font></b></td></tr>'''
				)
				
				sb.append(genAttributes(node.name, relevantAttributes))
				
				for (AttackDetectionRateValue dRate : relevantDRates) {
					sb.append('''<tr><td>Detection Rate = «dRate.value.value»</td></tr>''')
				}
				
				sb.append('''</table>>]''')
				sb.append("\n")
			}
			sb.append("\n")
			return sb.toString
		}
		
		def genAttributes(String nodeID, ArrayList<Attribute> attributes) {
			if (attributes.empty) {
				return ""
			}
			var sb = new StringBuffer()
			sb.append('''<tr><td><b>Attributes</b></td></tr>''')
			for (Attribute attribute : attributes) {
				for (AttributeValue attributeValue : attribute.values) {
					if ((getNodeName(attributeValue.attribute)).equals(nodeID)) {
						sb.append('''<tr><td>«attribute.name» = «attributeValue.value.evalExpr»</td></tr>''')
					}
				}
			}
			return sb.toString()			
		}
		
		//Generate defense nodes
		def genDefenseNodes(Iterator<DefenseNode> defenseNodes, List<Attribute> attributes, List<DefenseEffectivenessValues> effectivenessValues) {
			if (defenseNodes.empty) {
				return ""
			}
			var sb = new StringBuffer()
			sb.append(
				'''
				//DefenseNodes definitions
				node [shape=box color=green]
				'''
			)
			while (defenseNodes.hasNext) {
				var node = defenseNodes.next
				var relevantAttributes = getRelevantAttributes(node.name, attributes.iterator)
				var values = getRelevantEffectivenessValues(node.name, effectivenessValues.iterator)
				sb.append(
					'''
					«node.name» [label=<<table border="0"><tr><td><b><font point-size='20'>«node.name»</font></b></td></tr>
					'''
				)
				
				sb.append(genAttributes(node.name, relevantAttributes))
				sb.append(genDefenseEffectivenessValues(node.name, values))
					
					
				sb.append('''</table>>]''')
				sb.append("\n")	

				}
				
			
			
			return sb.toString
		}
		
		//Generate countermeasure nodes
		def genCountermeasureNodes(Iterator<CountermeasureNode> cmNodes, List<Attribute> attributes, List<DefenseEffectivenessValues> effectivenessValues) {
			if (cmNodes.empty) {
				return ""
			}
			var sb = new StringBuffer()
			var sbTriggers = new StringBuffer()
			sb.append(
				'''
				//CountermeasureNodes definitions
				node [shape=diamond color=purple]
				'''
			)
			while (cmNodes.hasNext) {
				var node = cmNodes.next
				var relevantAttributes = getRelevantAttributes(node.name, attributes.iterator)
				var values = getRelevantEffectivenessValues(node.name, effectivenessValues.iterator)
				sb.append(
					'''
					«node.name» [label=<<table border="0"><tr><td><b><font point-size='20'>«node.name»</font></b></td></tr>
					'''
				)
				sb.append(genAttributes(node.name, relevantAttributes))
				sb.append(genDefenseEffectivenessValues(node.name, values))
				sb.append('''</table>>]''')
				sbTriggers.append(genTriggers(node))
			}

			sb.append("\n")	
			sb.append("//Triggers\n")
			sb.append(sbTriggers.toString + "\n")
			return sb.toString
		}
		
		//Generate triggers for a countermeasure node
		def genTriggers(CountermeasureNode node) {
			var sb = new StringBuffer()
			var sbActivations = new StringBuffer()
			//sb.append('''«node.name» -> ''')
			var triggers = node.triggers.iterator
				
			while (triggers.hasNext) {
				var trigger = triggers.next
				if (triggers.hasNext) {
					//sb.append('''«trigger.name» ''')
					sbActivations.append('''«trigger.name» ''')
				} else {
					//sb.append(trigger.name)
					sbActivations.append(trigger.name)
				}
					
			}
			//sb.append("} [style=dashed arrowhead=\"none\"]\n")
			sb.append('''{«sbActivations»} -> «node.name» [style=dashed color=blue arrowhead="vee" penwidth=4.0]''')
			sb.append("\n")
			return sb.toString
		}
		
		def cleanStateName(ProcessState state){
			var name = state.name
			return cleanStateName(name)
		}
		def cleanStateName(String name){
			var cleanedName=name
			if(name.startsWith("s")){
				cleanedName = name.substring(1)
			}
			return cleanedName
		}
		
//		def genStates(Iterator<AttacksOfDiagram> attackDiagrams) {
//			var sb = new StringBuffer()
//			while (attackDiagrams.hasNext) {
//				var diagram = attackDiagrams.next
//				var states = diagram.eAllContents.filter(typeof(ProcessState))
//				sb.append(
//				'''
//				subgraph «diagram.attacker.name» {
//					//States
//					node [shape=box style=rounded color=blue penwidth=4.0]
//				'''
//				)
//				while (states.hasNext) {
//					var state = states.next
//					sb.append("\t")
//					sb.append(
//					'''
//					«cleanStateName(state.name)»
//					''')
//				}
//			
//				var transitions = diagram.eAllContents.filter(typeof(ProcessTransition))
//				sb.append("\t")
//				sb.append(
//				'''
//				//Transitions
//					edge [color=blue penwidth=2.0]
//				'''
//				)
//				while (transitions.hasNext) {
//					var transition = transitions.next
//					sb.append("\t")
//					sb.append(
//						'''
//						«cleanStateName(transition.source.name)» -> «cleanStateName(transition.target.name)» [label="«genAction(transition.action as StoreModifierActionOrReferenceToAction)»,«evalExpr(transition.rate) as double»"]
//						'''
//					)
//				}
//				sb.append("}\n")			
//			}
//
//			
//			return sb.toString
//		}


def genStates(Iterator<AttacksOfDiagram> attackDiagrams,List<InitialAttack> initialAttacks) {
			var sb = new StringBuffer()
			var attacker=initialAttacks.get(0).attacker
			while (attackDiagrams.hasNext) {
				var diagram = attackDiagrams.next
				if(diagram.attacker.name==attacker.name){
					var states = diagram.eAllContents.filter(typeof(ProcessState))
				sb.append(
				'''
				subgraph «diagram.attacker.name» {
					//States
					node [shape=box style=rounded color=blue penwidth=4.0]
				'''
				)
				while (states.hasNext) {
					var state = states.next
					sb.append("\t")
					sb.append(
					'''
					«cleanStateName(state.name)»
					''')
				}
			
				var transitions = diagram.eAllContents.filter(typeof(ProcessTransition))
				sb.append("\t")
				sb.append(
				'''
				//Transitions
					edge [color=blue penwidth=2.0]
				'''
				)
				while (transitions.hasNext) {
					var transition = transitions.next
					sb.append("\t")
					sb.append(
						'''
						«cleanStateName(transition.source.name)» -> «cleanStateName(transition.target.name)» [label="«genAction(transition.action as StoreModifierActionOrReferenceToAction)»,«evalExpr(transition.rate) as double»"]
						'''
					)
				}
				sb.append("}\n")	
				}
				else{
					//do nothing	
				}
			}

			
			return sb.toString
		}

//def genStates(List<InitialAttack> initialAttacks) {
//			var sb = new StringBuffer()			
//			initialAttacks.get(0).attacker.eContainer.
//			var states =initialAttacks.get(0).attacker.eAllContents.filter(typeof(ProcessState))
//			var attacker=initialAttacks.get(0).attacker
//			//while (attackDiagrams.hasNext) {
//				//var diagram = attackDiagrams.next
//				//var states = diagram.eAllContents.filter(typeof(ProcessState))
//				sb.append(
//				'''
//				subgraph «attacker.name» {
//					//States
//					node [shape=box style=rounded color=blue penwidth=4.0]
//				'''
//				)
//				while (states.hasNext) {
//					var state = states.next
//					sb.append("\t")
//					sb.append(
//					'''
//					«cleanStateName(state.name)»
//					''')
//				//}
//			
//				var transitions = initialAttacks.get(0).eAllContents.filter(typeof(ProcessTransition))
//				sb.append("\t")
//				sb.append(
//				'''
//				//Transitions
//					edge [color=blue penwidth=2.0]
//				'''
//				)
//				while (transitions.hasNext) {
//					var transition = transitions.next
//					sb.append("\t")
//					sb.append(
//						'''
//						«cleanStateName(transition.source.name)» -> «cleanStateName(transition.target.name)» [label="«genAction(transition.action as StoreModifierActionOrReferenceToAction)»,«evalExpr(transition.rate) as double»"]
//						'''
//					)
//				}
//				sb.append("}\n")			
//			}
//
//			
//			return sb.toString
//		}
		
		
		//Retrieve attributes relevant to given node(ID)
		def getRelevantAttributes(String nodeID, Iterator<Attribute> attributes) {
			var relevantAttributes = new ArrayList<Attribute>()
			while (attributes.hasNext) {
				var attribute = attributes.next
				var attributeValues = attribute.values.iterator
				var breakFlag = true
				while (attributeValues.hasNext && breakFlag) {
					var attributeValue = attributeValues.next
					if ((getNodeName(attributeValue.attribute)).equals(nodeID)) {
						relevantAttributes.add(attribute)
						breakFlag = false
					}
				}
			}
			return relevantAttributes
		}
		
		def getRelevantDRates(String nodeID, Iterator<AttackDetectionRateValue> detectionRates) {
			var dRates = new ArrayList<AttackDetectionRateValue>()
			while (detectionRates.hasNext) {
				var dRateValue = detectionRates.next
				if ((dRateValue.attackNode.name).equals(nodeID)) {
					dRates.add(dRateValue)
				}
			}
			
			return dRates
		}
		
		def getRelevantEffectivenessValues(String nodeID, Iterator<DefenseEffectivenessValues> effectivenessValues) {
			var values = new ArrayList<DefenseEffectivenessValues>()
			while (effectivenessValues.hasNext) {
				var value = effectivenessValues.next
				if ((getNodeName(value.defenseNode)).equals(nodeID)) {
					values.add(value)
				}
			}
			return values
		}
		
		def genDefenseEffectivenessValues(String nodeID, ArrayList<DefenseEffectivenessValues> values) {
			if (values.empty) {
				return ""
			}
			var sb = new StringBuffer()
			sb.append('''<tr><td><b>Defense Effectiveness</b></td></tr>''')
			for (DefenseEffectivenessValues value : values) {
				var valuesAttackers = value.defenseEffectivenessAttackers.attackers
				var valuesNodes = value.attackNodes.nodes
				
				sb.append('''<tr><td>''')
				
				if (valuesAttackers.empty) {
					sb.append('''ALL : ''')
				} else {
					if (valuesAttackers.length > 1) {
						sb.append("(")
						for (Attacker attacker : valuesAttackers) {
								if (valuesAttackers.last == attacker) {
								sb.append('''«attacker.name»''')
							} else {
								sb.append('''«attacker.name», ''')
							}
						}
						sb.append(''') : ''')
					} else {
						sb.append('''«(valuesAttackers.get(0)).name» : ''')
					}
				}	
				if (valuesNodes.empty) {
					sb.append('''ALL = ''')
				} else {
					if (valuesNodes.length > 1) {
						sb.append("(")
						for (AttackNode attackNode : valuesNodes) {
							if (valuesNodes.last == attackNode) {
								sb.append('''«attackNode.name»''')
							} else {
								sb.append('''«attackNode.name», ''')
							}
						}
						sb.append(''') = ''')
					} else {
						sb.append('''«(valuesNodes.get(0)).name» = ''')
					}
				}
				sb.append('''«value.value.value»''')
				sb.append('''</td></tr>''')
			}
			return sb.toString
		}
		
		//Generate all relations
		def genEdges(Iterator<EdgeType> edges) {
			var sb = new StringBuffer()
			var sbRanks = new StringBuffer()
			var invisibleDOTNodeCounter = 0
			sb.append(
				'''
				//Edges
				rankdir = TB
				edge [penwidth=2.0]
				'''
			)
			while (edges.hasNext) {
				var edge = edges.next
				var parent = edge.parent
				var children = getChildren(edge)
				
				switch (edge.eClass.name) {
					case "ORRelation": {
						for (child : children) {
							sb.append('''«getNodeName(parent)» -> «getNodeName(child)»''')
							if (parent.eClass != child.eClass) {
								sb.append(''' [style="dashed" arrowhead="none" color="gray"]''')
							} else {
								sb.append(''' [arrowhead="none"]''')
							}
							sb.append("\n")
						}
						
					}
					case "ANDRelation": {
						var invisibleDOTNodeStart = invisibleDOTNodeCounter
						for (child : children) {
							sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» [shape=point style=invis label="" width=0.0 height=0.0]''')
							sb.append("\n")
							sb.append('''«getNodeName(parent)» -> invisibleDOTNode«invisibleDOTNodeCounter»''')
							if (parent.eClass != child.eClass) {
								sb.append(''' [style="dashed" arrowhead="none"]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [style="dashed" arrowhead="none"]''')
								sb.append("\n")
							} else {
								sb.append(''' [arrowhead="none" penwidth=2]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [arrowhead="none" penwidth=2]''')
								sb.append("\n")
							}
							invisibleDOTNodeCounter++
						}
						var invisibleDOTNodeEnd = invisibleDOTNodeCounter
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd - 1; i++) {
							sb.append('''invisibleDOTNode«i» -> invisibleDOTNode«i + 1» [arrowhead="none"]''')
							sb.append("\n")
						}
						sbRanks.append('''{rank = same; ''')
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd; i++) {
							sbRanks.append('''invisibleDOTNode«i»;''')
						}
						sbRanks.append("}\n")
						sbRanks.append('''{rank = same; ''')
						for (child : children) {
							sbRanks.append('''«getNodeName(child)»;''')
						}
						sbRanks.append("}\n")
					}
					case "OANDRelation": {
						var invisibleDOTNodeStart = invisibleDOTNodeCounter
						for (child : children) {
							sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» [shape=point style=invis label="" width=0.0 height=0.0]''')
							sb.append("\n")
							sb.append('''«getNodeName(parent)» -> invisibleDOTNode«invisibleDOTNodeCounter»''')
							if (parent.eClass != child.eClass) {
								sb.append(''' [style="dashed" arrowhead="none"]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [style="dashed" arrowhead="none"]''')
								sb.append("\n")
							} else {
								sb.append(''' [arrowhead="none" penwidth=2]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [arrowhead="none" penwidth=2]''')
								sb.append("\n")
							}
							invisibleDOTNodeCounter++
							
						}
						var invisibleDOTNodeEnd = invisibleDOTNodeCounter
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd - 1; i++) {
							if (i == invisibleDOTNodeEnd - 2) {
								sb.append('''invisibleDOTNode«i» -> invisibleDOTNode«i + 1» [arrowhead="vee"]''')
							} else {
								sb.append('''invisibleDOTNode«i» -> invisibleDOTNode«i + 1» [arrowhead="none"]''')
							}
							
							sb.append("\n")
						}
						sbRanks.append('''{rank = same; ''')
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd; i++) {
							sbRanks.append('''invisibleDOTNode«i»;''')
						}
						sbRanks.append("}\n")
						sbRanks.append('''{rank = same; ''')
						for (child : children) {
							sbRanks.append('''«getNodeName(child)»;''')
						}
						sbRanks.append("}\n")
					}
					case "KNRelation": {
						//var invisibleDOTNodeStart = invisibleDOTNodeCounter
						for (child : children) {
							sb.append('''«getNodeName(parent)»-> «getNodeName(child)» [arrowhead="none" penwidth=2 label="«(edge as KNRelation).value»:«children.length»"]''')
							sb.append("\n")	
							/*
							sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» [shape=point style=invis label="" width=0.0 height=0.0]''')
							sb.append("\n")
							sb.append('''«getNodeName(parent)» -> invisibleDOTNode«invisibleDOTNodeCounter»''')
							if (parent.eClass != child.eClass) {
								sb.append(''' [style="dashed" arrowhead="none" ]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [style="dashed" arrowhead="none" label="«(edge as KNRelation).value»:«children.length»"]''')
								sb.append("\n")
							} else {
								sb.append(''' [arrowhead="none" penwidth=2]''')
								sb.append("\n")
								sb.append('''invisibleDOTNode«invisibleDOTNodeCounter» -> «getNodeName(child)» [arrowhead="none" penwidth=2 label="«(edge as KNRelation).value»:«children.length»"]''')
								sb.append("\n")
							}
							invisibleDOTNodeCounter++
							*/
						}
						/*
						var invisibleDOTNodeEnd = invisibleDOTNodeCounter
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd - 1; i++) {
							sb.append('''invisibleDOTNode«i» -> invisibleDOTNode«i + 1» [arrowhead="none"]''')
							sb.append("\n")
						}
						sbRanks.append('''{rank = same; ''')
						for (var i = invisibleDOTNodeStart; i < invisibleDOTNodeEnd; i++) {
							sbRanks.append('''invisibleDOTNode«i»;''')
						}
						sbRanks.append("}\n")
						sbRanks.append('''{rank = same; ''')
						for (child : children) {
							sbRanks.append('''«getNodeName(child)»;''')
						}
						sbRanks.append("}\n")
						*/
					}
					
				}
				
				

			}
			sb.append(sbRanks.toString)
			return sb.toString
		}
		
		def genORRelation(ORRelation edge) {
			var sb = new StringBuffer()
			var parent = edge.parent
			var children = edge.childrenSet.children
			for (Node child : children) {
				sb.append('''«getNodeName(parent)» -> «getNodeName(child)»''')
				if (parent.eClass != child.eClass) {
					sb.append(" [style=\"dashed\" arrowhead=\"none\"]")
				} else {
					sb.append(" [arrowhead=\"none\"]")
				}
				sb.append("\n")
			}
			return sb.toString
		}
		
		def genANDRelation(ANDRelation edge) {
			
		}
		
		def genOANDRelation(OANDRelation edge) {
			
		}
		
		def genKNRelation(KNRelation edge) {
			
		}
		
		def getChildren(EdgeType edge) {
			switch (edge.eClass.name) {
				case "ORRelation": {
					return (edge as ORRelation).childrenSet.children
				}
				case "ANDRelation": {
					return (edge as ANDRelation).childrenSet.children
				}
				case "OANDRelation": {
					return (edge as OANDRelation).childrenSeq.children
				}
				case "KNRelation": {
					return (edge as KNRelation).childrenSet.children
				}
			}
		}
		

		//Get SetOfChildren/SeqOfChildren
		def getChildrenSet(Iterator<Node> children) {
			var sb = new StringBuffer()
			sb.append("{")
			
			var child = children.next
			sb.append(getNodeName(child))
			while (children.hasNext) {
				child = children.next
				sb.append(''' «getNodeName(child)»''')
			}
			sb.append("}")
			return sb.toString
		}
		
		//Generate attributes
		def genAttributes(Iterator<Attribute> attributes) {
			//var sb = new StringBuffer()
		}
		
		def static double evalExpr(Expression expr) {
		var rightVisited = 0.0
		var leftVisited = 0.0
		if(expr instanceof NumberLiteral){
			return expr.value
		}
		else if(expr instanceof RefToVariable){
			//return expr.varname.name
			return 0.0
		}
		else if(expr instanceof Predicate){
			//return expr.predicate.name
			return 0.0
		}
		else if(expr instanceof Addition || expr instanceof AdditionWithPredicates){
			if(expr instanceof Addition){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			else if(expr instanceof AdditionWithPredicates){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			//return '''«leftVisited» + «rightVisited»'''
			return leftVisited + rightVisited
		}
		else if(expr instanceof Subtraction || expr instanceof SubtractionWithPredicates){
			if(expr instanceof Subtraction){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			else if(expr instanceof SubtractionWithPredicates){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			//return '''«leftVisited» - «rightVisited»'''
			return leftVisited - rightVisited
		}
		else if(expr instanceof Multiplication || expr instanceof MultiplicationWithPredicates){
			if(expr instanceof Multiplication){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			else if(expr instanceof MultiplicationWithPredicates){
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
			}
			//return '''«leftVisited» * «rightVisited»'''
			return leftVisited * rightVisited
		}
		else if (expr instanceof Division) {
			leftVisited = evalExpr(expr.left)
			rightVisited = evalExpr(expr.right)
			return leftVisited / rightVisited
		}
		else if (expr instanceof Power) {
			leftVisited = evalExpr(expr.left)
			rightVisited = evalExpr(expr.right)
			return leftVisited ** rightVisited
		}
		else if(expr instanceof MinusPrimary || expr instanceof MinusPrimaryWithPredicates){
			if(expr instanceof MinusPrimary){
				leftVisited = evalExpr(expr.left)
			}
			else if(expr instanceof MinusPrimaryWithPredicates){
				leftVisited = evalExpr(expr.left)
			}
			//return '''-«leftVisited»'''
			return -leftVisited
		}
		else{
			throw new UnsupportedOperationException("Unsupported expression: " + expr.toString());
		}
	}
	
	def static cleanActionName(String name){
		var cleanedName = name
		if(name.equalsIgnoreCase("tryAction") || name.equalsIgnoreCase("tryAct")){
			cleanedName = "try"
		}
		return cleanedName
	}
	
	def static genAction(StoreModifierActionOrReferenceToAction action) {
			if(action instanceof Action){
				return cleanActionName(action.name)
			}
			else if(action instanceof ReferenceToAction){
				var referencedActionOrFeautre = action.value
				var ret=referencedActionOrFeautre.name
				if(referencedActionOrFeautre instanceof Action){
					ret= cleanActionName(ret)
				}
				return ret
			}
			else if(action instanceof StoreModifierActions){
				if(action instanceof AddAction){
					return '''add(«action.node.nodeName»)'''
				}
				else if(action instanceof RemoveAction){
					return '''remove(«action.node.nodeName»)'''
				}
				else if(action instanceof FailAction){
					return '''fail(«action.node.nodeName»)'''
				}
				else if(action instanceof QueryAction){
					return '''query(«action.node.nodeName»)'''
				}
				else{
					throw new UnsupportedOperationException("Unsupported action: " + action);
				}
			}
		}

		

	

		
}
