/*
 * generated by Xtext 2.13.0
 */
package atree.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.Iterator

import atree.xtext.bbt.Node
import atree.xtext.bbt.AttackNode
import atree.xtext.bbt.DefenseNode
import atree.xtext.bbt.EdgeType
import atree.xtext.bbt.ORRelation
import atree.xtext.bbt.ANDRelation
import atree.xtext.bbt.OANDRelation
import atree.xtext.bbt.KNRelation
import atree.xtext.bbt.CountermeasureNode
import atree.xtext.bbt.ModelDefinition
import atree.xtext.bbt.Variable
import atree.xtext.bbt.Expression
import atree.xtext.bbt.NumberLiteral
import atree.xtext.bbt.RefToVariable
import atree.xtext.bbt.Predicate
import atree.xtext.bbt.Addition
import atree.xtext.bbt.AdditionWithPredicates
import atree.xtext.bbt.Subtraction
import atree.xtext.bbt.SubtractionWithPredicates
import atree.xtext.bbt.Multiplication
import atree.xtext.bbt.MultiplicationWithPredicates
import atree.xtext.bbt.MinusPrimary
import atree.xtext.bbt.MinusPrimaryWithPredicates
import atree.xtext.bbt.Attribute
import atree.xtext.bbt.Attacker
import atree.xtext.bbt.DefenseEffectivenessValues
import atree.xtext.bbt.Action
import atree.xtext.bbt.ActionConstraints
import atree.xtext.bbt.QuantitativeConstraints
import atree.xtext.bbt.AttacksOfDiagram
import atree.xtext.bbt.InitialAttack
import atree.xtext.MyParserUtil
import atree.xtext.bbt.AttackDetectionRateValue
import atree.xtext.bbt.ActionRequires
import atree.xtext.bbt.StoreModifierActionOrReferenceToAction
import atree.xtext.bbt.ReferenceToAction
import atree.xtext.bbt.StoreModifierActions
import atree.xtext.bbt.AddAction
import atree.xtext.bbt.RemoveAction
import atree.xtext.bbt.FailAction
import atree.xtext.bbt.QueryAction
import atree.xtext.bbt.BoolExpr
import atree.xtext.bbt.HasNode
import atree.xtext.bbt.AllowedNode
import atree.xtext.bbt.FalseConstraint
import atree.xtext.bbt.TrueConstraint
import atree.xtext.bbt.NotConstraintExpr
import atree.xtext.bbt.AndBoolConstraintExpr
import atree.xtext.bbt.OrBoolConstraintExpr
import atree.xtext.bbt.ImpliesBoolConstraintExpr
import atree.xtext.bbt.DisequationOfPredicateExpr
//import atree.xtext.bbt.ProcessTransition
//import atree.xtext.bbt.ZeroProcess
//import atree.xtext.bbt.ReferenceToProcessState
import atree.xtext.bbt.AskOrStoreModifierActionOrReferenceToAction
import atree.xtext.bbt.SideEffects
import java.util.HashMap
import java.util.Set
import java.util.HashSet
import java.util.List
import atree.xtext.bbt.Analysis
import atree.xtext.bbt.NonParametricQueries
import atree.xtext.bbt.ParametricQuery
import java.util.LinkedHashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BbtGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		var modelDefs = resource.allContents.filter(typeof(ModelDefinition))
		var modelDef = modelDefs.next
		var modelName = modelDef.name
		var variables = resource.allContents.filter(typeof(Variable))
		var attackNodes = resource.allContents.filter(typeof(AttackNode)).toList
		var defenseNodes = resource.allContents.filter(typeof(DefenseNode))
		var countermeasureNodes = resource.allContents.filter(typeof(CountermeasureNode))
		var relations = resource.allContents.filter(typeof(EdgeType))
		var attributes = resource.allContents.filter(typeof(Attribute))
		var attackers = resource.allContents.filter(typeof(Attacker))
		var defenseEffectiveness = resource.allContents.filter(typeof(DefenseEffectivenessValues))
		var actions = resource.allContents.filter(typeof(Action))
		var detectionRates = resource.allContents.filter(typeof(AttackDetectionRateValue))
		var listOfActionConstraints = resource.allContents.filter(typeof(ActionConstraints))
		var listOfQuantitativeConstraints = resource.allContents.filter(typeof(QuantitativeConstraints))
		var attackDiagrams = resource.allContents.filter(typeof(AttacksOfDiagram))
		var initialAttacks = resource.allContents.filter(typeof(InitialAttack)).toList

		var javaEncoding =//'''package it.imt.qflan.core.models;
'''

import atree.core.attacker.*;
import atree.core.attributes.*;
import atree.core.model.*;
import atree.core.nodes.*;
import atree.core.processes.*;
import atree.core.processes.actions.*;
import atree.core.processes.constraints.*;
import atree.core.variables.*;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class «modelName» implements IAtreeModelBuilder {
	
	public «modelName»(){
		System.out.println("Model builder instantiated");
	}
	public AtreeModel createModel(){
		
		AtreeModel model = new AtreeModel();		
		
		//////////////////
		/////Variables////
		//////////////////
		«writeVariables(variables)»
		
		/////////////
		////Nodes////
		/////////////
		«writeAttackNodes(attackNodes.iterator)»
		«writeDefenseNodes(defenseNodes)»
		«writeCountermeasureNodes(countermeasureNodes)»
		
		/////////////////
		////Relations////
		/////////////////
		«writeRelations(relations)»
		
		//////////////////
		////Attributes////
		//////////////////
		«writeAttributes(attributes)»
		
		/////////////////
		////Attackers////
		/////////////////
		«writeAttackers(attackers)»
		
		/////////////////////////////
		////Defense Effectiveness////
		/////////////////////////////
		«writeDefenseEffectiveness(defenseEffectiveness)»
		
		///////////////
		////Actions////
		///////////////
		«writeActions(actions)»
		
		//////////////////////////////
		////Attack Detection Rates////
		//////////////////////////////
		«writeDetectionRates(detectionRates)»
		
		////////////////////////////////
		////Quantitative Constraints////
		////////////////////////////////
		«writeQuantitativeConstraints(listOfQuantitativeConstraints)»
		
		//////////////////////////
		////Action Constraints////
		//////////////////////////
		«writeActionConstraints(listOfActionConstraints,attackNodes)»
		
		///////////////////////
		////Attack Diagrams////
		///////////////////////
		«writeAttackDiagrams(attackDiagrams,initialAttacks)»
		
		///////////////////////
		////Initial Attacks////
		///////////////////////
		«writeInitialAttacks(initialAttacks)»
		
		return model;
	}
}
'''
		fsa.generateFile(modelName+'.java',javaEncoding)
		
for(e : modelDef.elements){
			if(e instanceof Analysis){
				var query = e.query;
				if(query!==null){
					var queryString=""
					if(query instanceof NonParametricQueries){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=true;
						//hasUntilQuery=false;
					}
					else if(query instanceof ParametricQuery){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=true;
						//hasNonParametricQueries=false;
						//hasUntilQuery=false;
					}
//					else if(query instanceof UntilQuery){
//						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=false;
						//hasUntilQuery=true;
//					} 
					
				
					if(queryString!==null && !queryString.equals("")){
						fsa.generateFile('query'+modelName+'.quatex', queryString)
					}
				}
			}
		}
		
		/*fsa.generateFile(modelName+'.java', 
			'All defined actions: ' + 
			resource.allContents
				.filter(typeof(Action))
				.map[name]
				.join(', '))*/
	
	
	
	}
		
		def writeInitialAttacks(List<InitialAttack> initAttacks) {
			var StringBuffer sb = new StringBuffer()
			//TODO: FIX HERE IF ONLY 1 INITIALATTACK!!!!
			if (!initAttacks.empty){
//				while (attacks.hasNext){
				var init = initAttacks.get(0)
				var attacker = init.attacker.name
//				var initialAttacks = init.initialAttacks
				var StringBuffer ia = new StringBuffer("Arrays.asList(")
				if (init.initialAttacks !== null && !init.initialAttacks.empty){
					for (a : init.initialAttacks){
						ia.append(a.name)
						ia.append(",")
					}
					ia.delete(ia.length-1,ia.length);
				}
				ia.append(")")
				sb.append(
'''
model.init(«attacker»,«ia.toString»);
'''
				)
//				}
			}
			return sb.toString
		}
		
		def writeAttackDiagrams(Iterator<AttacksOfDiagram> diagrams,List<InitialAttack> initAttacks) {
			var StringBuffer sb = new StringBuffer();
			var String currentAttacker = null;
			if (!initAttacks.empty){
				currentAttacker = initAttacks.get(0).attacker.name;
			}
			if (!diagrams.empty){
				while (diagrams.hasNext){
					var boolean initialState = true;
					var diagram = diagrams.next
					if (currentAttacker !== null && diagram.attacker.name == currentAttacker){	//Probably requires initial attacks as a method parameter...
						for (state : diagram.states.states){
							sb.append(
'''
ProcessState «state.name» = new ProcessState("«state.name»");
'''
							)
							if (initialState){
								initialState = false
								sb.append(
'''
model.setInitialState(«state.name»);
'''
								)
							}
						}
						for (transition : diagram.transitions.transitions){
							var rate = MyParserUtil.visitExpr(transition.rate)
							var source = transition.source.name
							var target = transition.target.name//computeTarget(transition)
							var sideEffects = visitListOfSideEffects(transition.sideEffects);
							var action = writeActionIncludingAskOrStoreModifierOrFeature(transition.action)
							var actionGuard = visitActionGuard(transition.actionGuard)
							sb.append(
'''
«source».addTransition(new ProcessTransition(«rate»,«action»,«target»,«sideEffects»,«actionGuard»));
'''
							)
						}
					}
				}
				
			}
			return sb.toString
		}
		
		def static visitActionGuard(BoolExpr expr) {
			if (expr !== null){
				return visitConstraint(expr)
			}
			else {
				return "new TrueConstraint()"
			}
		}
		
		def static visitListOfSideEffects(SideEffects effects) {
		var sb = new StringBuilder();
		sb.append("new SideEffect[]{");
		
		if(effects!==null){
			var listOfEffects = effects.effects;
			var size = listOfEffects.size;
			var i=0;
			if(listOfEffects!==null){
				for(eff : listOfEffects){
					var name = eff.refToVar.varname.name
					var expr = eff.value;
					sb.append('''new SideEffect(«name»,«writeExpr(expr)»)''')
					if(i<size-1){
						sb.append(",");
					}
					i++;
				}
			}
		}
		sb.append("}");
		return sb.toString;
	}
		
		def static writeActionIncludingAskOrStoreModifierOrFeature(AskOrStoreModifierActionOrReferenceToAction action) {
		if(action instanceof StoreModifierActionOrReferenceToAction){
			return writeActionIncludingStoreModifierOrFeature(action)
		}
		else{
			throw new UnsupportedOperationException("Unsupported action: " + action);
		} 
	}
		
//		def static computeTarget(ProcessTransition transition){
//		var target="ZeroProcess.ZERO"
//		var tt=transition.target
//		if(!(tt instanceof ZeroProcess)){
//			var tt2 = tt as ReferenceToProcessState
//			target = tt2.value.name
//		}
//		return target
//	}
		
		def writeQuantitativeConstraints(Iterator<QuantitativeConstraints> constraints) {
			var StringBuffer sb = new StringBuffer()
			if (!constraints.empty){
				var quantitativeConstraints = constraints.next
				for (constraint : quantitativeConstraints.quantitativeConstraints){
					sb.append(
'''
model.addConstraint(«visitConstraint(constraint)»);
'''
					)
				}
			}
			return sb.toString
		}
		
		def writeActionConstraints(Iterator<ActionConstraints> constraints, List<AttackNode> anodes) {
			var StringBuffer sb = new StringBuffer()
			if (!constraints.empty){
				var actionConstraints = constraints.next
				for (actionReq : actionConstraints.actionConstraints){
					sb.append(
'''
model.addActionConstraint(«visitActionRequires(actionReq)»);
'''
					)
				}
			}
			// This is where do(add/fail/remove/query(node))->(!has(root)) could be specified. Would require all attack nodes to be parsed...
//			sb.append('''//Basic action constraints. Dont perform an action, if root is reached. \n''')
//			var root = anodes.get(0)
			return sb.toString
		}
		
		def static visitActionRequires(ActionRequires constraint) {
			var writtenAction = writeActionIncludingStoreModifierOrFeature(constraint.action)
			var writtenConstraint = visitConstraint(constraint.constraint)
			return '''new ActionRequiresConstraint(«writtenAction», «writtenConstraint»)'''
		}
		
		def static String visitConstraint(BoolExpr constraint) {
			if(constraint instanceof HasNode){
				return '''new HasNodeConstraint(«getNodeName(constraint.node)»)'''
			}
			else if(constraint instanceof AllowedNode){
				return '''new AllowedNodeConstraint(«getNodeName(constraint.node)»)'''
			}
			else if(constraint instanceof FalseConstraint){
				return '''new FalseConstraint()'''
			}
			else if(constraint instanceof TrueConstraint){
				return '''new TrueConstraint()'''
			}
			else if(constraint instanceof NotConstraintExpr){
				return '''new NotConstraintExpr(«visitConstraint(constraint.left)»)'''
			}
			else if(constraint instanceof AndBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.AND)'''
			}
			else if(constraint instanceof OrBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.OR)'''
			}
			else if(constraint instanceof ImpliesBoolConstraintExpr){
				return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.IMPLIES)'''
			}
			else if(constraint instanceof DisequationOfPredicateExpr){
				var writtenlhs = writeExpr(constraint.lhs)
				var writtenrhs = writeExpr(constraint.rhs)
				return '''new DisequationOfAttributeExpressions(«writtenlhs»,«writtenrhs»,«writeComparator(constraint.comp)»)''';
			}
			return ""
		}
		
		def static writeComparator(String comp) {
			if(comp.equals(">")){
				return "AttributeExprComparator.GE"
			}
			else if(comp.equals("<")){
				return "AttributeExprComparator.LE"
			}
			else if(comp.equals(">=")){
				return "AttributeExprComparator.GEQ"
			}
			else if(comp.equals("<=")){
				return "AttributeExprComparator.LEQ"
			}
			else if(comp.equals("==")){
				return "AttributeExprComparator.EQ"
			} 
			else if(comp.equals("!=")){
				return "AttributeExprComparator.NOTEQ"
			}
			else{
				throw new UnsupportedOperationException("Unsupported comparator: " + comp);
			}
		}
		
		def static writeActionIncludingStoreModifierOrFeature(StoreModifierActionOrReferenceToAction action) {
			if(action instanceof Action){
				return action.name
			}
			else if(action instanceof ReferenceToAction){
				var referencedActionOrFeautre = action.value
				if(referencedActionOrFeautre instanceof Action){
					return referencedActionOrFeautre.name
				}
			}
			else if(action instanceof StoreModifierActions){
				if(action instanceof AddAction){
					return '''new AddAction(«action.node.nodeName»)'''
				}
				else if(action instanceof RemoveAction){
					return '''new RemoveAction(«action.node.nodeName»)'''
				}
				else if(action instanceof FailAction){
					return '''new FailAction(«action.node.nodeName»)'''
				}
				else if(action instanceof QueryAction){
					return '''new QueryAction(«action.node.nodeName»)'''
				}
				else{
					throw new UnsupportedOperationException("Unsupported action: " + action);
				}
			}
		}
		
		def writeDetectionRates(Iterator<AttackDetectionRateValue> values) {
			var StringBuffer sb = new StringBuffer();
			while (values.hasNext){
				var detectionRate = values.next
				sb.append(
'''
«detectionRate.attackNode.name».setDetectionRate(«MyParserUtil.visitExpr(detectionRate.value)»);
'''
				)
			}
			
			return sb.toString
		}
		
		def writeActions(Iterator<Action> actions) {
			var StringBuffer sb = new StringBuffer();
			while(actions.hasNext){
				var action = actions.next
				sb.append(
'''
NormalAction «action.name» = new NormalAction("«action.name»");
model.addNormalAction(«action.name»);
'''
)
			}
			return sb.toString();
	}	
		
		def writeDefenseEffectiveness(Iterator<DefenseEffectivenessValues> values) {
			var StringBuffer sb = new StringBuffer()
			while (values.hasNext){
				var deVal = values.next
				var StringBuffer attackNodes = new StringBuffer;
				var StringBuffer attackers = new StringBuffer;
				if (deVal.attackNodes.nodes.empty){
					attackNodes.append('''model.getAttackNodes()''')
				}
				else{
					attackNodes.append("Arrays.asList(")
					for (a : deVal.attackNodes.nodes){
						attackNodes.append(a.name)
						attackNodes.append(",")
					}
					attackNodes.delete(attackNodes.length-1,attackNodes.length);
					attackNodes.append(")")
				}
				if (deVal.defenseEffectivenessAttackers.attackers.empty){
					attackers.append('''model.getAttackers()''')
				}
				else {
					attackers.append("Arrays.asList(")
					for (a :deVal.defenseEffectivenessAttackers.attackers){
						attackers.append(a.name)
						attackers.append(",")	
					}
					attackers.delete(attackers.length-1,attackers.length);
					attackers.append(")")
				}
				sb.append(
'''
model.setDefenseEffectivenesss(«attackers.toString», «attackNodes.toString»,«deVal.defenseNode.nodeName»,«MyParserUtil.visitExpr(deVal.value)»);
'''
				)
			}
			return sb.toString
		}
		
		def writeAttackers(Iterator<Attacker> attackers) {
			var StringBuffer sb = new StringBuffer();
			while (attackers.hasNext){
				var a = attackers.next
				sb.append(
'''
Attacker «a.name» = new Attacker ("«a.name»");
model.addAttacker(«a.name»);
'''
				)
			}
			sb.toString
		}
		
		def writeAttributes(Iterator<Attribute> attributes) {
			var StringBuffer sb = new StringBuffer()
			while(attributes.hasNext) {
				var att = attributes.next
				sb.append(
'''
AttributeDef «att.name» = new AttributeDef("«att.name»");
model.addAttributeDef(«att.name»);
'''					
				)
				for (attVal : att.values){
					sb.append(
'''
«att.name».setNodeValue(«attVal.attribute.nodeName»,«MyParserUtil.visitExpr(attVal.value)»);
'''
					)
				}
			}
			return sb.toString;
		}
		
	def writeRelations(Iterator<EdgeType> edgeTypes) {
		var number = 0;
		var LinkedHashMap<String,Set<String>> orRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> andRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> knRelations = new LinkedHashMap<String,Set<String>>()
		var LinkedHashMap<String,Set<String>> oandRelations = new LinkedHashMap<String,Set<String>>()
		var StringBuffer sb = new StringBuffer(
'''
LinkedHashMap<String,Set<String>> orRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> andRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> knRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,Set<String>> oandRelations = new LinkedHashMap<>(); 
LinkedHashMap<String,List<String>> childrenMap = new LinkedHashMap<>();
LinkedHashMap<String,Integer> knChildren = new LinkedHashMap<>();
'''
		);
		while (edgeTypes.hasNext){
			var setID = "set" + number
			number++
			var edgeType = edgeTypes.next
			var key = getNodeName(edgeType.parent)
			var StringBuffer childLst = new StringBuffer("Arrays.asList(")
			var children = getRelationChildren(edgeType)
			
			if (!children.empty){
				for (c : children){
					childLst.append('''"«c.nodeName»"''')
					childLst.append(",")
				}
				childLst.delete(childLst.length-1,childLst.length)
			}
			childLst.append(")")
			sb.append(
'''
childrenMap.put("«setID»",«childLst.toString»);
'''
			)
			if (edgeType instanceof ORRelation){
				if (orRelations.containsKey(key)){
					orRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					orRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof ANDRelation){
				if (andRelations.containsKey(key)){
					andRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					andRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof KNRelation){
				sb.append(
'''
knChildren.put("«setID»",«edgeType.value»);
'''
				)
				if (knRelations.containsKey(key)){
					knRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					knRelations.put(key,setOfID)
				}
			}
			else if (edgeType instanceof OANDRelation){
				if (oandRelations.containsKey(key)){
					oandRelations.get(key).add(setID)
				}
				else{
					var Set<String> setOfID = new HashSet<String>()
					setOfID.add(setID)
					oandRelations.put(key,setOfID)
				}
			}
		}
		var buildOr = buildRelMap("orRelations",orRelations)
		var buildAnd = buildRelMap("andRelations",andRelations)
		var buildKn = buildRelMap("knRelations",knRelations)
		var buildOAnd = buildRelMap("oandRelations",oandRelations)

		sb.append(
'''
«buildOr»
«buildAnd»
«buildKn»
«buildOAnd»
model.addAllRelations(orRelations,andRelations,knRelations,oandRelations,childrenMap,knChildren);
'''			
		);
		return sb.toString();
	}
		
		def buildRelMap(String name, HashMap<String, Set<String>> map) {
			var StringBuffer sb = new StringBuffer()
			for (key : map.keySet){
				sb.append('''«name».put("«key»",new HashSet<>(Arrays.asList(''')
				for (id : map.get(key)){
					sb.append('''"«id»"''')
					sb.append(",")
				}
				sb.delete(sb.length-1,sb.length)
				sb.append(")));\n")
			}
			return sb.toString
		}
	
	def writeAttackNodes(Iterator<AttackNode> nodes) {
		var sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			sb.append(
'''
AttackNode «node.name» = new AttackNode("«node.name»");
model.addAttackNodeDefinition(«node.name»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	def writeDefenseNodes(Iterator<DefenseNode> nodes) {
		var sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			sb.append(
'''
DefenseNode «node.name» = new DefenseNode("«node.name»");
model.addDefenseNodeDefinition(«node.name»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	def writeCountermeasureNodes(Iterator<CountermeasureNode> nodes) {
		var StringBuffer sb = new StringBuffer();
		while(nodes.hasNext){
			var node = nodes.next
			var aNodes = node.triggers
			var StringBuffer anl = new StringBuffer("Arrays.asList(");
			if (aNodes !== null){
				for (an : aNodes){
					anl.append(an.name)
					anl.append(",")
				}
			}
			anl.delete(anl.length-1,anl.length)
			anl.append(")")
			sb.append(
'''
CountermeasureNode «node.name» = new CountermeasureNode("«node.name»");
model.addCountermeasureNodeDefinition(«node.name»,«anl.toString»);
'''
			)
		}
		sb.append("\n")
		return sb.toString();
	}
	
	def writeVariables(Iterator<Variable> variables) {
		var sb = new StringBuffer();
		while(variables.hasNext){
			var variable = variables.next
			sb.append(
'''
AtreeVariable «variable.name» = model.addVariable("«variable.name»", «writeExpr(variable.value)»);
'''
)
		}
		sb.append("\n")
		return sb.toString();
	}
	
	def static String writeExpr(Expression expr) {
		var rightVisited = ""
		var leftVisited = ""
		if(expr instanceof NumberLiteral){
			return '''new Constant(«expr.value»)'''
		}
		else if(expr instanceof RefToVariable){
			return '''«expr.varname.name»'''
		}
		else if(expr instanceof Predicate){
			return '''new Attribute(«expr.predicate.name»)'''
		}
		else if(expr instanceof Addition || expr instanceof AdditionWithPredicates){
			if(expr instanceof Addition){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof AdditionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.SUM)'''
		}
		else if(expr instanceof Subtraction || expr instanceof SubtractionWithPredicates){
			if(expr instanceof Subtraction){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof SubtractionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.SUB)'''
		}
		else if(expr instanceof Multiplication || expr instanceof MultiplicationWithPredicates){
			if(expr instanceof Multiplication){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof MultiplicationWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticAttributeExpression(«leftVisited»,«rightVisited»,ArithmeticOperation.MULT)'''
		}
		else if(expr instanceof MinusPrimary || expr instanceof MinusPrimaryWithPredicates){
			if(expr instanceof MinusPrimary){
				leftVisited = writeExpr(expr.left) as String
			}
			else if(expr instanceof MinusPrimaryWithPredicates){
				leftVisited = writeExpr(expr.left) as String
			}
			return '''new ArithmeticAttributeExpression(new Constant(0),«leftVisited»,ArithmeticOperation.SUB)'''
		}
		else{
			throw new UnsupportedOperationException("Unsupported expression: " + expr.toString());
		}
	}
	
	def static getNodeName(Node n)
	{
		if(n instanceof AttackNode)
		{
			return n.name;
		}
		else if(n instanceof DefenseNode)
		{
			return n.name;
		} 
		else if(n instanceof CountermeasureNode)
		{
			return n.name;
		}
	}
	def static getRelationChildren(EdgeType e)
	{
		if (e instanceof ORRelation)
		{
			return e.childrenSet.children;
		}
		if (e instanceof ANDRelation)
		{
			return e.childrenSet.children
		}
		if (e instanceof OANDRelation)
		{
			return e.childrenSeq.children
		}
		if (e instanceof KNRelation)
		{
			return e.childrenSet.children
		}
	}
	

		
}
