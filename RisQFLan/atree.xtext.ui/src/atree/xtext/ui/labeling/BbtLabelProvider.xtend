/*
 * generated by Xtext 2.13.0
 */
package atree.xtext.ui.labeling

import com.google.inject.Inject
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import atree.xtext.bbt.Variables
import atree.xtext.bbt.AttackNodes
import atree.xtext.bbt.DefenseNodes
import atree.xtext.bbt.Edges
import atree.xtext.bbt.ORRelation
import atree.xtext.bbt.ANDRelation
import atree.xtext.bbt.OANDRelation
import atree.xtext.bbt.KNRelation
import atree.xtext.generator.BbtGenerator
import atree.xtext.bbt.Attributes
import atree.xtext.bbt.Attackers
import atree.xtext.bbt.AttributeValue
import atree.xtext.bbt.SideEffects
import atree.xtext.bbt.SideEffect
import atree.xtext.bbt.Expression
import atree.xtext.bbt.QuantitativeConstraints
import atree.xtext.bbt.BoolExpr
import atree.xtext.bbt.Analysis
import atree.xtext.bbt.MultiQuatexQuery
import atree.xtext.bbt.Node
import atree.xtext.bbt.Actions
import atree.xtext.bbt.ActionConstraints
import atree.xtext.bbt.States
import atree.xtext.bbt.Transitions
import atree.xtext.bbt.AttackDiagram
import atree.xtext.bbt.AttacksOfDiagram
import atree.xtext.bbt.ProcessTransition
//import atree.xtext.bbt.ZeroProcess
//import atree.xtext.bbt.ReferenceToProcessState
import atree.xtext.bbt.CountermeasureNodes
import atree.xtext.bbt.AttackDetectionRates
import atree.xtext.bbt.AttackDetectionRateValue
import atree.xtext.bbt.DefenseEffectiveness
import atree.xtext.bbt.DefenseEffectivenessValues
import atree.xtext.bbt.InitialAttacks
import atree.xtext.bbt.InitialAttack

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class BbtLabelProvider extends DefaultEObjectLabelProvider {

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}
	
	def text(Variables variables)
	{
		write("Variable", variables.getVariables().length());
	}
	
	def text(AttackNodes nodes)
	{
		write("Attack Node", nodes.getAttackNodes().length());
	}
	
	def text(DefenseNodes nodes)
	{
		write("Defense Node", nodes.getDefenseNodes().length());
	}
	
	def text(CountermeasureNodes nodes)
	{
		write("Countermeasure Node", nodes.getCountermeasureNodes().length());
	}
	
	def text(AttackDetectionRates adt)
	{
		write("Attack Detection Rate", adt.getValues().length());
	}
	
	def text(AttackDetectionRateValue v)
	{
		return v.attackNode.name;
	}
	
	def text(Edges edges)
	{
		return "Attack Tree";
	}
	
	def text(DefenseEffectiveness dp)
	{
		return "Defense Effectiveness";
	}
	
	def text(DefenseEffectivenessValues d)
	{
		return BbtGenerator.getNodeName(d.getDefenseNode());
	}
	
	def text(InitialAttacks i)
	{
		return "Initial Attacker Knowledge";
	}
	
	def text(InitialAttack i)
	{
		return i.getAttacker().name;
	}
	
//	def text(DefenseProbability dp)
//	{
//		return dp.getAttacker().name + " [" + write("Node", dp.getValues().length()) + "]";
//	}
//	
//	def text(ProbabilityValue pv)
//	{
//		return BbtGenerator.getNodeName(pv.getNode());
//	}
	
//	def text(AttackModels am)
//	{
//		write("Attack Model", am.getAttackModels().length());
//	}
//	
//	def text(AttackModel am)
//	{
//		return am.getAttacker().name + " Attacker [" + write("Action", am.getValues().length()) + "]";
//	}
//	
//	def text(AttackModelState ams)
//	{
//		return ams.getNode().name;
//	}
//	
//	def text(OptionalAttackParameters oap)
//	{
//		return "Optional Attack Parameters";
//	}
//	
//	def text(SuccessFailure sf)
//	{
//		return "Success/Failure";
//	}
	
	def text(SideEffects se)
	{
		write("Side Effect", se.getEffects().length());
	}
	
	def text(Expression e) //Hot fix for now
	{
		return "Expression";
	}
	
	def text(QuantitativeConstraints qc)
	{
		write("Quantitative Constraint", qc.getQuantitativeConstraints().length());
	}
	
	def text(BoolExpr be) //Hot fix for now
	{
		return "Boolean Expression";
	}
	
	def text(Analysis a)
	{
		return "Analysis";
	}
	
	def text(MultiQuatexQuery q)
	{
		return "Query";
	}
	
	def text(States s)
	{
		write("State", s.getStates().length());
	}
	
	def text(Transitions t)
	{
		write("Transition", t.getTransitions().length());
	}
	
	def text(AttackDiagram a)
	{
		return "Attack Diagram - " + write ("Attack", a.getAttacks().length());
	}
	
	def text(AttacksOfDiagram a)
	{
		return a.getAttacker().name;
	}
	
	def text(ProcessTransition p)
	{
		return p.source.name + " -> " + p.target.name;//computeTarget(p); 
	}
	
//	def computeTarget(ProcessTransition transition) //Reuse from QFLAN
//	{
//		var target="nil"
//		var tt=transition.target
//		if(!(tt instanceof ZeroProcess)){
//			var tt2 = tt as ReferenceToProcessState
//			target = tt2.value.name
//		}
//		return target
//	}
	
	def text(SideEffect se)
	{
		return se.getRefToVar().varname.name;
	}
	
	def text(ORRelation p)
	{
		
		return BbtGenerator.getNodeName(p.parent) + " -OR-> {" + pwrite("Child", "Children", p.getChildrenSet().getChildren().length()) + "}";
	}
	
	def text(ANDRelation a)
	{
		return BbtGenerator.getNodeName(a.parent) + " -AND-> {" + pwrite("Child", "Children", a.getChildrenSet().getChildren().length()) + "}";
	}
	
	def text(OANDRelation o)
	{
		return BbtGenerator.getNodeName(o.parent) + " -OAND-> [" + pwrite("Child", "Children", o.getChildrenSeq().getChildren().length()) + "]";
	}
	
	def text(KNRelation k)
	{
		return BbtGenerator.getNodeName(k.parent) + " -K" + k.value + "-> {" + pwrite("Child", "Children", k.getChildrenSet().getChildren().length()) + "}";
	}
	
	def text(Node n)
	{
		return BbtGenerator.getNodeName(n);
	}
	
	def text(Attributes a)
	{
		write("Attribute", a.getAttributes().length());
	}
	
	def text(AttributeValue av)
	{
		return BbtGenerator.getNodeName(av.getAttribute());
	}
	
	def text(Attackers a)
	{
		write("Attacker", a.getAttackers().length());
	}
	
	def text(Actions a)
	{
		write("Action", a.getActions().length());
	}
	
	def text(ActionConstraints a)
	{
		write("Action Constraint", a.getActionConstraints().length());
	}	

	def write(String item, int size)
	{
		if (size <= 1)
		{
			return size + " " + item;
		}
		return size + " " + item + "s";
	}
	
	def pwrite(String item, String pitem, int size)
	{
		if (size <= 1)
		{
			return size + " " + item;
		}
		return size + " " + pitem;
	}
}
